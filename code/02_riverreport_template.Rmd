---
title: "River Report `r params$df$river[1]`"
output: 
  html_document:
    code_folding: hide
    css: styles.css
params:
  df: NULL
  generate: FALSE
---
```{r, include=FALSE}
source("functions.R")
knitr::opts_chunk$set(fig.width=14, fig.height=7, dpi=300, out.width="100%")
knitr::opts_knit$set(root.dir = normalizePath("."))

generate = params$generate

if (generate) {
  df = params$df
  river = df$river[1]
} else if (!generate) {
  df = cop_df |> dplyr::filter(river == "Isar")
  river = "Isar"
}
```


## The data set
`r river`

```{r}
knitr::kable(head(df))
```

Number of observation (i.e. observed years) differs between stations.

```{r}
# Some of the stations have VERY little observations...
nobs_unit = df |> dplyr::summarise(
  n = dplyr::n(),
  .by = unit
) |>
  dplyr::mutate(
    n_for_table = as.factor(dplyr::if_else(n > 30, ">30", as.character(n)))
  )

knitr::kable(table(nobs_unit$n_for_table))
```


## Aggregated view {.tabset}
Scatterplots of observed variables (Marginal affects Scatterplot) and Pseudo-Observations (Relationship only).

### Volume - Duration
```{r}
# Plots
# Volume-Duration
# With marginal distribution
p1 = ggplot(df, aes(x = volume, y = duration_min)) +
  geom_point() +
  facet_wrap(~unit)
# Pobs
p2 = ggplot(df, aes(x = pobs_vol, y = pobs_dur)) +
  geom_point() +
  facet_wrap(~unit)
p1p2 = (p1 | p2)
p1p2
```

### Volume - Peak
```{r}
# Volume-Peak
# W/ marginal
p1 = ggplot(df, aes(x = volume, y = peak)) +
  geom_point() +
  facet_wrap(~unit)
# Pobs (relation without marginal)
p2 = ggplot(df, aes(x = pobs_vol, y = pobs_peak)) +
  geom_point() +
  facet_wrap(~unit)
p1p2 = (p1 | p2)
plot(p1p2)
```


### Duration - Peak
```{r}
# Duration-Peak
# W/ marginal
p1 = ggplot(df, aes(x = duration_min, y = peak)) +
  geom_point() +
  facet_wrap(~unit)
# Pobs
p2 = ggplot(df, aes(x = pobs_dur, y = pobs_peak)) +
  geom_point() +
  facet_wrap(~unit)
p1p2 = (p1|p2)
plot(p1p2)
```


## Correlation table
```{r}
# Correlation table
cor_table = df|> dplyr::summarise(
  n = dplyr::n(),
  tau_vd = cor(volume, duration_min, method = "kendall"),
  p_vd = cor.test(volume, duration_min, method = "kendall")$p.value,
  rej_vd = p_vd < 0.01,
  tau_vp = cor(volume, peak, method = "kendall"),
  p_vp = cor.test(volume, peak, method = "kendall")$p.value,
  rej_vp = p_vp < 0.01,
  tau_dp = cor(duration_min, peak, method = "kendall"),
  p_dp = cor.test(duration_min, peak, method = "kendall")$p.value,
  rej_dp = p_dp < 0.01,
  .by = unit
)
knitr::kable(cor_table)
```


```{r}
# Distribution of dependence structures
cor_table |> tidyr::pivot_longer(
  cols = c("tau_vd", "tau_vp", "tau_dp"),
  names_to = "relation",
  values_to = "correlation"
) |>
ggplot(aes(y = correlation, x = relation)) +
  geom_boxplot()

```
Averages for more than 10 observations
```{r}
means = cor_table |> dplyr::filter(n > 10) |> dplyr::summarise(
  vd_mean = mean(tau_vd),
  vp_mean = mean(tau_vp),
  dp_mean = mean(tau_dp)
)
knitr::kable(means)
```
Mean of smaller correlation
```{r}
mean(c(means$vp_mean, means$dp_mean))
```
Mean of Means
```{r}
mean(c(means$vd_mean, means$vp_mean, means$dp_mean))
```



## Fitted Copulas {.tabset}



```{r}
river_units = (df |> dplyr::summarise(n = dplyr::n(), .by = unit))$unit

```

### NACs {.tabset}
```{r}
nac_fams = list("1" = "Gumbel", "3" = "Clayton", "5" = "Frank")
nacs = lapply(
  river_units,
  function(name){
    fit_nac(mat = df |> dplyr::filter(unit == name) |> dplyr::select(contains("pobs")) |> as.matrix(), families = c(1, 3, 5))
  }
)
names(nacs) = river_units

# Only compare AICs with vine AICs. I do really not care for any NAC plots. MAYBE if AICs of NACs is a lot smaller than for vine. Then it suggests actually NAC strucutre, but I do not expect this since we have 3 different taus...
```


<!-- #### Trees -->

<!-- ```{r} -->
<!-- par(mfrow = c(y, x)) -->
<!-- invisible( -->
<!--   lapply( -->
<!--     river_units, -->
<!--     function(name){ -->
<!--       plot(nacs[[name]], main = paste(name, "-", nac_fams[as.character(nacs[[name]]$type)])) -->
<!--     } -->
<!--   ) -->
<!-- ) -->
<!-- par(mfrow = c(1, 1)) -->
<!-- ``` -->

<!-- #### Contours -->

<!-- ```{r} -->
<!-- for (name in river_units){ -->
<!--   nac = nacs[[name]] -->
<!--   cnac = HAC::hac2nacopula(nac) -->
<!--   inner_cop = copula::archmCopula(family = cnac@copula@name, param = cnac@copula@theta) -->
<!--   contour(inner_cop, dCopula, n.grid = 450) -->
<!--   outer_cop = copula::archmCopula(family = cnac@childCops[[1]]@copula@name, param = cnac@childCops[[1]]@copula@theta) -->
<!--   contour(x = outer_cop, FUN = dCopula, n.grid = 200) -->
<!-- } -->
<!-- ``` -->

### Vines {.tabset}

```{r}
# Fit Vines

assumed_vine_structure =  matrix(
  # 1 - 2 - 3 where: 1:dur, 2:peak, 3:vol
    c(
      1, 0, 0,
      3, 2, 0,
      2, 3, 3
    ),
    nrow = 3, ncol = 3,
    byrow = TRUE
  )

vines = lapply(
  river_units,
  function(name) {
    mat = df |> dplyr::filter(unit == name) |> dplyr::select(contains("pobs")) |> as.matrix() 
    
    vine = VineCopula::RVineCopSelect(data = mat, Matrix = assumed_vine_structure, familyset = c(3, 4, 5))
  }
)
names(vines) = river_units

```

#### Trees

```{r}
# Optiomal plot dimensions
y = ceiling(sqrt(length(river_units)))
x = ceiling(length(river_units) / y)

par(mfrow = c(y, x))
invisible( # Allows lapply to work well with plot
  lapply(
    river_units, 
    function(name) {
      plot(vines[[name]], type = 2, edge.labels = "family-tau", tree = 1)
      title(sub = name)
    }
  )
)
par(mfrow = c(1, 1))

```

#### Contours / synthetic data {.tabset}

My ggplot densities are not correct. No way. But I do not know why. I mean, the contour plots of the VineCopula package actually look different to mine. But no idea why.... Problem for later. yey.

Only based on the vines fit as they obviously fit the data way better. 

```{r}
# Contours
x = seq(from = 0.01, to = 0.99, length.out = 50)
y = seq(from = 0.01, to = 0.99, length.out = 50)
density_grid = expand.grid(x = x, y = y)

plot_dfs = lapply(
  river_units,
  function(name) get_density_values(vines[[name]], density_grid, name)
)
plot_df = plot_dfs |> dplyr::bind_rows()

# For the copula density to be displayed also towards the edges of the plot, keep the binwidth low.
# I liked 
# density_binwidth = 0.01
# But for now, keep it high so it renders faster
density_binwidth = 1
```


```{r}
# Synthetic data
n_syn = 1000
syn_dfs = lapply(
  river_units,
  function(name) get_synthetic_data(vines[[name]], n_syn, name)
)
syn_df = syn_dfs |> dplyr::bind_rows()
```

```{r}
syn_df = syn_df |> 
  dplyr::mutate(
    vol = inverse_ecdf_unitwise(u = pobs_vol, data = df, data_col = "vol", unit = unit),
    .by = unit
  )
# Append inversed, synthetic data 
syn_df$peak = lapply(
  river_units,
  function(name) inverse_ecdf_unitwise(syn = syn_df, syn_col = "pobs_peak", df = df, df_col = "peak", unit_name = name)
) |> unlist()
syn_df$vol= lapply(
  river_units,
  function(name) inverse_ecdf_unitwise(syn = syn_df, syn_col = "pobs_vol", df = df, df_col = "volume", unit_name = name)
) |> unlist()
syn_df$dur= lapply(
  river_units,
  function(name) inverse_ecdf_unitwise(syn = syn_df, syn_col = "pobs_dur", df = df, df_col = "duration_min", unit_name = name)
) |> unlist()
```

##### Volume - Duration

```{r}
# 1: pobs_dur, 2: pobs_peak, 3: pobs_vol
# 1 - 2 - 3
p1 = ggplot() +
  # 1: pobs_dur, 2: pobs_peak, 3: pobs_vol
  geom_contour(data = plot_df |> dplyr::filter(vars == "z13_2"), aes(x = x, y = y, z = density), binwidth = density_binwidth, alpha = .1) + 
  geom_point(data = df, mapping = aes(x = pobs_vol, y = pobs_dur), alpha = .8) +
  facet_wrap(~ unit)
p2 = ggplot() + 
  geom_point(data = syn_df, mapping = aes(x = vol, y = dur), color = "lightblue") + 
  geom_point(data = df, mapping = aes(x = volume, y = duration_min)) + 
  facet_wrap(~ unit)
p1p2 = (p1 | p2)
p1p2
```


##### Volume - Peak

```{r}
# 1: pobs_dur, 2: pobs_peak, 3: pobs_vol
# 1 - 2 - 3
p1 = ggplot() +
  geom_contour(data = plot_df |> dplyr::filter(vars == "z23"), aes(x = x, y = y, z = density), binwidth = density_binwidth, alpha = .1) + 
  geom_point(data = df, mapping = aes(x = pobs_vol, y = pobs_peak), alpha = .8) +
  facet_wrap(~ unit)
p2 = ggplot() + 
  geom_point(data = syn_df, mapping = aes(x = vol, y = peak), color = "lightblue") + 
  geom_point(data = df, mapping = aes(x = volume, y = peak)) + 
  facet_wrap(~ unit)
p1p2 = (p1 | p2)
p1p2
```

##### Duration - Peak

```{r}
# 1: pobs_dur, 2: pobs_peak, 3: pobs_vol
# 1 - 2 - 3
p1 = ggplot() +
  # 1: pobs_dur, 2: pobs_peak, 3: pobs_vol
  geom_contour(data = plot_df |> dplyr::filter(vars == "z12"), aes(x = x, y = y, z = density), binwidth = density_binwidth, alpha = .1) + 
  geom_point(data = df, mapping = aes(x = pobs_dur, y = pobs_peak), alpha = .8) +
  facet_wrap(~ unit)
p2 = ggplot() + 
  geom_point(data = syn_df, mapping = aes(x = dur, y = peak), color = "lightblue") + 
  geom_point(data = df, mapping = aes(x = duration_min, y = peak)) + 
  facet_wrap(~ unit)
p1p2 = (p1 | p2)
p1p2
```


```{r}
# MYYY DENSITIES ARE WROOOOOOOOOOONG I THINK!!!
# Checked: The Bivariate copulas used to grab density values are correct. Checked this using:
# test = function(){
#   browser()
#   contour(vines[["Sylvenstein"]])
# }
# test()
# --> Allows to jump into the source code and check fitted BiCop. For Sylvenstein that is:
# Bivariate copula: Frank (par = 12.72, tau = 0.73) (vine matrix index: [2, 1]) (family integer: 5)
# Bivariate copula: Clayton (par = 1, tau = 0.33) (vine matrix index: [3, 1])  (family integer: 3)
# Bivariate copula: Survival Gumbel (par = 2.03, tau = 0.51) (vine matrix index: [3, 2]) (family int: 14)
# MY DENSITIES ARE CORREEEEEEEEEEEEEEEECT!!!! 
# Package by default plots their densites using normal margins! I plot them on uniform margins
# Compare mine to package when using uniform margins:
# contour(vines[["Sylvenstein"]], margins = "unif")
# But still, the dependence plot look a lot better with normal margins? wtf...
```


```{r}
# Plot the copula densities and sythetic data. Helps me figuring out what is going wrong... I hope?
# Plot them side by side 
```


## Fit comparison

Check if there are any NACs with huge AIC ratio. In generally, just compare confidence in vine selection vs NAC selection by considering the AIC ratio with NAC AIC / Vine AIC. Only if this ratio is super large and small n, the underlying strucutre might actually be NAC which is, due to the small sample size, badly approximated using vines. 

At least for Isar, there is not one concerning AIC ratio. That is, for presentation: We keep in mind, that if AIC ratio is super large favoring NACs for small sample sizes, we should (probably) fit NAC. For any other case, vines are perfectly fine. 
For Isar, there is only one case where NAC AIC is larger than vine AIC, but still close to 1. So all good. 

Thus, NACs are not relevant at all. Thus, plot Contours only for Vines.

Vines just beat NACs in every aspect in our considered case, really. 
```{r}
# Check if NACs are relevant. If not, only plot Vine density contours with obs data 
nac_aic = unlist(
  lapply(
    nacs, 
    function(nac) ll2aic(attr(nac, "logLik")[[1]], p = 2) 
  )
)
vine_aic = unlist(lapply(vines, function(vine) return(vine$AIC)))
aic = data.frame(
  nac_aic = nac_aic,
  vine_aic = vine_aic,
  aic_ratio = nac_aic / vine_aic
)
aic |> 
  ggplot(aes(y = aic_ratio)) + 
  geom_boxplot()
```
### Single Station
```{r}
if (river == "Isar") station = "MÃ¼nchen" else station = df$unit[1]
```

Zoomed density and synthetic data

```{r}
# station df 
sdf = df |> dplyr::filter(unit == station)
# station plot_df
splot_df = plot_df |> dplyr::filter(unit == station)
# station synthetic df 
ssyn_df = syn_df |> dplyr::filter(unit == station) 
```

```{r}

get_syn_scatter = function(ssyn_df, var1_syn, var2_syn, sdf, var1_df, var2_df){
  p = ggplot() + 
    geom_point(data = ssyn_df, mapping = aes_string(x = var1_syn, y = var2_syn), color = "lightblue") + 
    geom_point(data = sdf, mapping = aes_string(x = var1_df, y = var2_df)) 
  return(p)
}

p1 = get_contour("z12", splot_df, sdf, "pobs_dur", "pobs_peak")
p2 = get_contour("z23", splot_df, sdf, "pobs_peak", "pobs_vol")
p3 = get_contour("z13_2", splot_df, sdf, "pobs_vol", "pobs_peak")
p4 = get_syn_scatter(ssyn_df, "dur", "peak", sdf, "duration_min", "peak")
p5 = get_syn_scatter(ssyn_df, "peak", "vol", sdf, "peak", "volume")
p6 = get_syn_scatter(ssyn_df, "vol", "peak", sdf, "volume", "peak")
p = (p1 | p2 | p3) / 
    (p4 | p5 | p6)
p
```
Marginal plots with and without synthetic data

```{r}
ggplot() + 
  geom_density(data = ssyn_df, mapping = aes(x = peak), color = "blue", alpha = 0.5) + 
  geom_density(data = sdf, mapping = aes(x = peak)) 
```
```{r}
plot(ecdf(c(ssyn_df$dur, ssyn_df$vol)))
```






### Tail dependence
```{r}
tdeps = lapply(
  river_units,
  function(name) get_tail_dependencies(vines[[name]], name)
)
tdep = tdeps |> dplyr::bind_rows()
knitr::kable(tdep)
```


